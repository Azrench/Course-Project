#define _CRT_SECURE_NO_WARNINGS// Отключение предупреждений о небезопасных функциях в Visual Studio
#include <stdio.h> // Подключение стандартной библиотеки ввода-вывода
#include <stdlib.h> // Подключение стандартной библиотеки функций общего назначения
#include <stdbool.h>// Подключение библиотеки для работы с логическими значениями
#include <string.h> // Подключение библиотеки для работы со строками
#include <locale.h> // Подключение библиотеки для работы с локализаей
#define MAX_SIZE 9 // Определение макроса с именем MAX_SIZE и значением 9
#define TARGET_SUM 100// Определение макроса с именем TARGET_SUM и значением 100
void printMatrix(int** matrix, int rows, int cols);
bool findSolution(int** matrix, int rows, int cols, int x, int y, int* rowSums, int* colSums);


int possibleValues[10][19] =// Объявление и инициализация двумерного массива possibleValues
{
    {0, 10, 20, 30, 40, 50, 60, 70, 80, 90},  // Для 0
    {1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 31, 41, 51, 61, 71, 81, 91},  // Для 1
    {2, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 12, 32, 42, 52, 62, 72, 82, 92},  // Для 2
    {3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 13, 23, 43, 53, 63, 73, 83, 93},  // Для 3
    {4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 14, 24, 34, 54, 64, 74, 84, 94},  // Для 4
    {5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 15, 25, 35, 45, 65, 75, 85, 95},  // Для 5
    {6, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 16, 26, 36, 46, 56, 76, 86, 96},  // Для 6
    {7, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 17, 27, 37, 47, 57, 67, 87, 97},  // Для 7
    {8, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 18, 28, 38, 48, 58, 68, 78, 98},  // Для 8
    {9, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 19, 29, 39, 49, 59, 69, 79, 89}   // Для 9
};
int main()//Главная функция программы
{
    setlocale(LC_ALL, "RUS");// Устанавливаем локаль для корректного отображения текста на русском языке.
    system("color F0");  // Устанавливаем цвет фона и текста в консоли.
    printf("Вас приветствует игра головоломка Сто («Hundred»)!\nДля выбора необходимого пункта в главном меню игры, введите число от 1-го до 4-х.\n"); // Выводим приветственное сообщение и инструкцию для пользователя.
    int rows, cols, answer, file_answer, f_rows, f_cols, score, row_sum_counter, col_sum_counter, lives, c; // Объявляем необходимые переменные для игры.
    int** matrix;
    int rowSums[MAX_SIZE] = { 0 };
    int colSums[MAX_SIZE] = { 0 };
    int user_matrix[MAX_SIZE][MAX_SIZE];
    bool win = false;
    FILE* file;
    while (1)  // Создаем цикл для главного меню игры.
    {
        printf("Главное меню игры:\n1. Показать правила игры.\n2. Новая игра.\n3. Головоломка для ИИ.\n4. Выход из игры.\nВаш ответ: ");
        scanf("%d", &answer); // Получаем ответ пользователя.
        if (answer == 1)// Если пользователь выбрал пункт 1, выводим правила игры.
        {
            printf("Сто («Hundred») состоит из квадратной сетки в виде кроссворда/головоломки, в каждой клетке которой проставлены цифры. Требуется поставить дополнительные цифры таким образом (слева, или справа цыфры в чейке), чтобы сумма всех чисел в каждом ряду и в каждом столбце была равна 100.\n");
        }
        else if (answer == 2 || answer == 3) // Если пользователь выбрал пункт 2 или 3, подготавливаемся к новой игре или игре для ИИ.
        {
            row_sum_counter = 0;
            col_sum_counter = 0;
            lives = 3;
            win = false;
            printf("Хотите восстановить предыдущее игровое поле?\n1. Да.\n2. Нет.\n");// Получаем ответ пользователя.
            scanf("%d", &file_answer);// Открываем файл для получения предыдущего игрового поля.
            file = fopen("temp.txt", "r");
            int rows = 0, cols = 0, ch;
            if (answer == 2)// Если пользователь выбрал начать новую игру, устанавливаем игровое поле в исходное состояние.
            {
                if (file_answer == 1)
                {
                   
                    int matrix[10][10]; // Обнуляем игровую матрицу для новой игры.
                    for (int i = 0; i < 10; i++)
                    {
                        for (int k = 0; k < 10; k++)
                        {
                            matrix[i][k] = 0;
                        }
                    }
                    if (file == NULL) // Если файл не удалось открыть, выводим сообщение об ошибке и завершаем программу.
                    {
                        printf("Не удалось открыть файл.\n");
                        return 1;
                    }

                    char sym[5] = ""; // Объявление массива символов и инициализация его пустой строкой
                    char s = '\0'; // Объявление символьной переменной и инициализация символом-завершителем строки

                    int r = 0; // Объявление переменной целого типа и инициализация нулевым значением
                    int l = 0; // Объявление переменной целого типа и инициализация нулевым значением

                    // Цикл while выполняется, пока s не равно EOF
                    while (s != EOF)
                    {
                        s = fgetc(file); // Считывание символа из файла в переменную s

                        // Проверка условий для символа s (' ' (пробел), '\n' (символ новой строки), EOF)
                        if (s == ' ' || s == '\n' || s == EOF)
                        {
                            int len = strlen(sym); // Определение длины строки в массиве sym
                            matrix[r][l] = atoi(sym); // Преобразование строки в числовой формат и сохранение в матрице

                            for (int x = 0; x < len + 1; x++)
                                sym[x] = '\0'; // Очистка массива sym

                            if (s == '\n') // Если символ s равен '\n'
                            {
                                l = 0; // Сброс счетчика столбцов
                                r++; // Увеличение счетчика строк
                            }
                            else if (s == EOF) // Если символ s равен EOF
                                break; // Прерывание работы цикла
                            else // Если символ s не равен ни '\n', ни EOF
                                l++; // Увеличение счетчика столбцов
                        }
                        else
                        {
                            sym[strlen(sym)] = s; // Добавление символа s в массив sym
                        }
                    }

                    int len_r = 0; // Объявление переменной целого типа для максимальной длины строки
                    int len_c = 0; // Объявление переменной целого типа для максимальной длины столбца

                    for (int i = 0; i < 10; i++) // Цикл для прохода по элементам массива
                    {
                        int mt = matrix[i][0]; // Значение первого элемента в строки массива
                        int mc = matrix[0][i]; // Значение первого элемента в столбце массива

                        if (mt != 0) // Если значение первого элемента строки не равно нулю
                            len_r++; // Увеличение счетчика максимальной длины строки

                        if (mc != 0) // Если значение первого элемента столбца не равно нулю
                            len_c++; // Увеличение счетчика максимальной длины столбца
                    }

                    printf("Начальное игровое поле:\n");
                    for (int i = 0; i < len_r; i++) // Цикл для прохода по строкам матрицы
                    {
                        for (int k = 0; k < len_c; k++) // Цикл для прохода по элементам строки матрицы
                        {
                            printf("%d ", matrix[i][k]); // Вывод элементов матрицы
                        }
                        printf("\n"); // Переход на новую строку
                    }
                    fclose(file); // Закрытие файла
                    row_sum_counter = 0; // Обнуление счетчика суммы по строкам
                    col_sum_counter = 0; // Обнуление счетчика суммы по столбцам
                    lives = 3; // Установка начального значения жизней
                    win = false; // Установка флага победы в ложь
                    while (lives != 0 || win == false) // Начало цикла while, который будет выполняться до тех пор, пока у игрока есть жизни или он не победит
                    {
                        printf("Ваше решение: \n"); // Выводит приглашение для игрока ввести свое решение
                        printf("Введите элементы головоломки построчно через пробел:\n"); // Запрос ввода элементов головоломки у пользователя

                        for (int i = 0; i < rows; i++) // Цикл для обхода строк матрицы пользователя
                        {
                            for (int j = 0; j < cols; j++) // Цикл для обхода столбцов матрицы пользователя
                            {
                                scanf("%d", &user_matrix[i][j]); // Ввод элементов матрицы пользователя
                            }
                        }
                        for (int i = 0; i < rows; i++) // Цикл для проверки суммы элементов строк
                        {
                            int sum = 0; // Переменная для хранения суммы элементов строки
                            for (int j = 0; j < cols; j++) // Цикл для обхода столбцов матрицы пользователя
                            {
                                sum += user_matrix[i][j]; // Вычисление суммы элементов строки
                            }
                            if (sum == 100) // Проверка выполнения условия суммы элементов строки
                            {
                                row_sum_counter++; // Увеличение счетчика, если сумма элементов равна 100
                            }
                            else
                            {
                                printf("Ошибка: сумма элементов строки %d не равна 100.\n", i + 1); // Вывод сообщения об ошибке, если сумма элементов строки не равна 100
                                return 1; // Выход из программы с кодом ошибки
                            }
                        }
                        // Проверка сумм столбцов
                        for (int j = 0; j < cols; j++) // Цикл для проверки суммы элементов столбцов
                        {
                            int sum = 0; // Переменная для хранения суммы элементов столбца
                            for (int i = 0; i < rows; i++) // Цикл для обхода строк матрицы пользователя
                            {
                                sum += user_matrix[i][j]; // Вычисление суммы элементов столбца
                            }
                            if (sum == 100) // Проверка выполнения условия суммы элементов столбца
                            {
                                col_sum_counter++; // Увеличение счетчика, если сумма элементов равна 100
                            }
                            else
                            {
                                printf("Ошибка: сумма элементов столбца %d не равна 100.\n", j + 1); // Вывод сообщения об ошибке, если сумма элементов столбца не равна 100
                                return 1; // Выход из программы с кодом ошибки
                            }
                        }
                        if (rows == row_sum_counter && cols == col_sum_counter) // Проверка выполнения условия, что суммы элементов строк и столбцов равны 100 для всех строк и всех столбцов
                        {
                            printf("Браво! Поздравляем с победой! :)\n"); // Вывод сообщения о победе
                            score = rows * 13 + cols * 13 + lives * 100 + 1000; // Вычисление количества заработанных очков за решение головоломки
                            printf("Количество заработанных очков за решение головоломки: %d\n", score); // Вывод количества заработанных очков
                            win = true; // Установка флага победы в значение "истина"
                            break; // Выход из цикла while
                        }
                        else
                        {
                            lives--; // Уменьшение количества жизней
                            printf("Неверно! Попробуйте еще раз.\nОставшееся количество жизней: %d\n", lives); // Вывод сообщения о неверном решении и количестве оставшихся жизней
                            if (lives == 0) // Проверка условия, что количество жизней равно нулю
                            {
                                printf("Игра окончена! Повезет в следующий раз. :("); // Вывод сообщения об окончании игры, если количество жизней равно нулю
                                break; // Выход из цикла while
                            }
                        }
                    }
                }
                else if (file_answer == 2)
                {
                    printf("Введите количество строк (от 1 до %d): ", MAX_SIZE);
                    scanf("%d", &rows);
                    if (rows < 1 || rows > MAX_SIZE)  // Если количество строк меньше 1 или больше MAX_SIZE
                    {
                        printf("Неверное количество строк.\n"); // Выводим сообщение о неверном количестве строк
                        continue; // Пропускаем оставшуюся часть итерации цикла и переходим к следующей итерации
                    }

                    printf("Введите количество столбцов (от 1 до %d): ", MAX_SIZE);
                    scanf("%d", &cols);
                    if (cols < 1 || cols > MAX_SIZE)  // Если количество столбцов меньше 1 или больше MAX_SIZE
                    {
                        printf("Неверное количество столбцов.\n"); // Выводим сообщение о неверном количестве столбцов
                        continue; // Пропускаем оставшуюся часть итерации цикла и переходим к следующей итерации
                    }

                    matrix = (int**)malloc(rows * sizeof(int*)); // Выделяем память под указатель на указатель типа int размером rows
                    for (int i = 0; i < rows; i++)
                    {
                        matrix[i] = (int*)malloc(cols * sizeof(int)); // Выделяем память под каждую строку матрицы размером cols
                        for (int j = 0; j < cols; j++)
                        {
                            printf("Введите элемент [%d][%d]: ", i + 1, j + 1);
                            scanf("%d", &matrix[i][j]);
                            rowSums[i] += matrix[i][j]; // Добавляем значение элемента к сумме для строки
                            colSums[j] += matrix[i][j]; // Добавляем значение элемента к сумме для столбца
                        }
                    }
                    printf("Начальное игровое поле:\n");
                    // Выделение памяти для матрицы
                    // ... (печать матрицы и поиск решения)
                    printMatrix(matrix, rows, cols);
                    while (lives != 0 || win == false)
                    {
                        printf("Ваше решение: \n");
                        printf("Введите элементы головоломки построчно через пробел:\n");
                        for (int i = 0; i < rows; i++)
                        {
                            for (int j = 0; j < cols; j++)
                            {
                                scanf("%d", &user_matrix[i][j]); // Вводим значения пользовательской матрицы
                            }
                        }
                        for (int i = 0; i < rows; i++)
                        {
                            int sum = 0;
                            for (int j = 0; j < cols; j++)
                            {
                                sum += user_matrix[i][j]; // Считаем сумму элементов в строке пользовательской матрицы
                            }
                            if (sum == 100) // Если сумма элементов строки равна 100
                            {
                                row_sum_counter++; // Увеличиваем счетчик корректных строк
                            }
                            else
                            {
                                printf("Ошибка: сумма элементов строки %d не равна 100.\n", i + 1); // Выводим сообщение об ошибке
                            }
                        }
                    }
                    }
                    // Проверка сумм столбцов
                    for (int j = 0; j < cols; j++) // Цикл для перебора всех столбцов
                    {
                        int sum = 0; // Инициализация переменной sum для хранения суммы элементов в столбце
                        for (int i = 0; i < rows; i++) // Цикл для перебора всех строк в столбце
                        {
                            sum += user_matrix[i][j]; // Прибавление значения элемента к сумме
                        }
                        if (sum == 100) // Проверка суммы элементов в столбце
                        {
                            col_sum_counter++; // Увеличение счетчика корректных сумм столбцов
                        }
                        else
                        {
                            printf("Ошибка: сумма элементов столбца %d не равна 100.\n", j + 1); // Вывод сообщения об ошибке, если сумма не равна 100
                        }
                    }
                    if (rows == row_sum_counter && cols == col_sum_counter) // Проверка корректности сумм строк и столбцов
                    {
                        printf("Браво! Поздравляем с победой! :)\n"); // Вывод сообщения о победе
                        score = rows * 13 + cols * 13 + lives * 100 + 1000; // Вычисление количества очков за решение головоломки
                        printf("Количество заработанных очков за решение головоломки: %d\n", score); // Вывод количества заработанных очков
                        win = true; // Установка флага победы в true
                        break; // Выход из цикла
                    }
                    else
                    {
                        lives -= 1; // Уменьшение количества жизней
                        printf("Неверно! Попробуйте еще раз.\nОставшееся количество жизней: %d\n", lives); // Вывод сообщения о неправильном ответе и оставшемся количестве жизней
                        if (lives == 0) // Проверка количества израсходованных жизней
                        {
                            printf("Игра окончена! Повезет в следующий раз. :(\n"); // Вывод сообщения о конце игры
                            break; // Выход из цикла
                        }
                    }
            }
                file = fopen("temp.txt", "w"); // Открытие файла "temp.txt" для записи
                if (file == NULL) // Проверка успешности открытия файла
                {
                    printf("Ошибка при открытии файла.\n"); // Вывод сообщения об ошибке при открытии файла
                }
                // Если пользователь выбрал пункт "Сохранить матрицу в файл"
            
                else if (answer == 3) // Если пользователь выбрал пункт "Загрузить матрицу из файла"
                {
                    if (file_answer == 1)  // Если пользователь выбрал пункт "Да" при запросе имени файла
                    {
                        int len_r = 0; // Объявление переменной len_r, которая будет хранить количество строк в матрице
                        int len_c = 0; // Объявление переменной len_c, которая будет хранить количество столбцов в матрице
                        char s = '\0'; // Инициализация символьной переменной s значением '\0'
                        char sym[5] = ""; // Массив символов sym, который будет использоваться для временного хранения чисел из файла
                        int r = 0; // Инициализация переменной r значением 0, для хранения текущего индекса строки в матрице
                        int l = 0; // Инициализация переменной l значением 0, для хранения текущего индекса столбца в матрице
                        // Цикл для чтения символов из файла пока s не достигнет конца файла (EOF)
                        while (s != EOF)
                        {
                            s = fgetc(file); // Считывание очередного символа из файла

                            // Проверка, является ли считанный символ пробелом, символом новой строки или концом файла
                            if (s == ' ' || s == '\n' || s == EOF)
                            {
                                // Определение длины строки в массиве sym и увеличение соответствующих счетчиков длины строк и столбцов в матрице
                                int len = strlen(sym);
                                if (len > 0)
                                {
                                    if (l == 0) // Проверка, является ли столбец пустым (l - индекс столбца)
                                        len_r++; // Если да, то увеличиваем счетчик количества строк на 1
                                    if (r == 0) // Проверка, является ли строка пустой (r - индекс строки)
                                        len_c++; // Если да, то увеличиваем счетчик количества столбцов на 1
                                }

                                // Очистка массива sym и подготовка к записи нового числа
                                for (int x = 0; x < len + 1; x++)
                                    sym[x] = '\0';

                                // Обновление индексов строк и столбцов в матрице при считывании символа новой строки или конца файла
                                if (s == '\n')
                                {
                                    l = 0; // Сброс индекса столбца
                                    r++; // Увеличение индекса строки на 1
                                }
                                else if (s == EOF)
                                    break; // Выход из цикла при достижении конца файла
                                else
                                    l++; // Увеличение индекса столбца на 1 при считывании следующего символа
                            }
                            else
                            {
                                sym[strlen(sym)] = s; // Запись считанного символа в массив sym
                            }
                        }

                        // Создаем массив с нужными размерами
                        int** matrix = (int**)malloc(len_r * sizeof(int*)); // Выделение памяти для массива указателей (строк матрицы)
                        for (int i = 0; i < len_r; i++) // Цикл по строкам матрицы
                        {
                            matrix[i] = (int*)malloc(len_c * sizeof(int)); // Выделение памяти для каждой строки (столбцов матрицы)
                            for (int k = 0; k < len_c; k++) // Цикл по столбцам матрицы
                            {
                                matrix[i][k] = 0; // Инициализация каждого элемента матрицы значением 0
                            }
                        }

                        // Считываем значения из файла в массив
                        rewind(file); // Перемещение указателя файла в начало
                        s = '\0'; // Обнуление переменной s
                        r = 0; // Обнуление индекса строки
                        l = 0; // Обнуление индекса
                        while (s != EOF) // Начало цикла: читаем символы из файла до тех пор, пока не достигнем конца файла
                        {
                            s = fgetc(file); // Читаем следующий символ из файла

                            if (s == ' ' || s == '\n' || s == EOF) // Если символ является пробелом или переводом строки или концом файла
                            {
                                int len = strlen(sym); // Вычисляем длину строки sym

                                if (len > 0) // Если строка sym не пустая
                                {
                                    matrix[r][l] = atoi(sym); // Преобразуем строку в целое число и записываем его в матрицу
                                    if (s == '\n') // Если символ является переводом строки
                                    {
                                        l = 0; // Сбрасываем счётчик столбца
                                        r++; // Переходим на следующую строку матрицы
                                    }
                                    else if (s == EOF) // Если достигнут конец файла
                                        break; // Выходим из цикла
                                    else
                                        l++; // Переходим к следующему столбцу матрицы
                                }

                                // Обнуляем символьную строку
                                for (int x = 0; x < len + 1; x++)
                                    sym[x] = '\0';
                            }
                            else // Если считанный символ не является пробелом, переводом строки или концом файла
                            {
                                sym[strlen(sym)] = s; // Добавляем символ в конец строки sym
                            }
                        }

                        // Проверяем, что файл не пустой
                        if (len_r == 0 || len_c == 0) // Если количество строк или столбцов равно 0
                        {
                            printf("Файл пустой.\n"); // Выводим сообщение о пустом файле
                            return 1; // Завершаем программу с ошибкой
                        }

                        // Остальной код без изменений

                        printf("Начальное игровое поле:\n"); // Выводим заголовок для начальной матрицы

                        // Выводим начальную матрицу и вычисляем суммы строк и столбцов
                        for (int i = 0; i < len_c * 4 - 1; i++)
                        {
                            printf("_"); // Выводим разделительную линию
                        }
                        printf("\n");
                        for (int i = 0; i < len_r; i++)
                        {
                            printf("|"); // Выводим начало строки
                            for (int k = 0; k < len_c; k++)
                            {
                                printf("%2d|", matrix[i][k]); // Выводим элементы матрицы
                                rowSums[i] += matrix[i][k]; // Вычисляем сумму элементов в строке
                                colSums[k] += matrix[i][k]; // Вычисляем сумму элементов в столбце
                            }
                            printf("\n");
                        }
                        for (int i = 0; i < len_c * 4 - 1; i++)
                        {
                            printf("-"); // Выводим разделительную линию
                        }
                        printf("\n");

                        fclose(file); // Закрываем файл

                        // Ищем решение задачи, используя функцию findSolution
                        if (findSolution(matrix, len_r, len_c, 0, 0, rowSums, colSums)) // Если удалось найти решение
                        {
                            printf("Решение найдено!\n"); // Выводим сообщение о найденном решении
                            printMatrix(matrix, len_r, len_c); // Выводим найденное решение
                        }
                        else // Если решение не найдено
                        {
                            printf("Решение не найдено!\n"); // Выводим сообщение об отсутствии решения
                        }

                        // Освобождаем память, выделенную для матрицы
                        for (int i = 0; i < len_r; i++)
                        {
                            free(matrix[i]);
                        }
                        free(matrix);
                    }
                else if (file_answer == 2)// Если пользователь выбрал пункт "Нет" при запросе имени файла
                {
                    printf("Введите количество строк (от 1 до %d): ", MAX_SIZE);// Запрос пользователю для ввода количества строк
                    scanf("%d", &rows);
                    if (rows < 1 || rows > MAX_SIZE)// Проверка валидности введенного количества строк
                    {
                        printf("Неверное количество строк.\n");
                        continue;

                    }
                    printf("Введите количество столбцов (от 1 до %d): ", MAX_SIZE); // Запрос пользователю для ввода количества столбцов
                    scanf("%d", &cols);
                    if (cols < 1 || cols > MAX_SIZE)// Проверка валидности введенного количества столбцов
                    {
                        printf("Неверное количество столбцов.\n");
                        continue;
                    }

                    matrix = (int**)malloc(rows * sizeof(int*));// Выделение памяти для указателей на строки матрицы
                    for (int i = 0; i < rows; i++)
                    {
                        matrix[i] = (int*)malloc(cols * sizeof(int)); // Выделение памяти для элементов внутри каждой строки матрицы
                        for (int j = 0; j < cols; j++)
                        {
                            printf("Введите элемент [%d][%d]: ", i + 1, j + 1);// Вывод вопроса на экран для ввода элемента матрицы
                            scanf("%d", &matrix[i][j]); // Получение значения элемента матрицы от пользователя
                            rowSums[i] += matrix[i][j]; // Подсчет суммы элементов в строке
                            colSums[j] += matrix[i][j]; // Подсчет суммы элементов в столбце
                        }
                    }
                    printf("Начальное игровое поле:\n");
               
                    printMatrix(matrix, rows, cols); // Вызов функции печати матрицы

                    if (findSolution(matrix, rows, cols, 0, 0, rowSums, colSums))//Вызов функции поиска решения
                    {
                        printf("Решение найдено!\n");// Печать сообщения о нахождении решения
                        printMatrix(matrix, rows, cols);// Печать матрицы с решением
                    }
                    else
                    {
                        lives--;// Уменьшение количества жизней
                        printf("Решение не найдено!\nУ вас осталось жизней: %d\nПопробуйте снова.\n", lives);// Печать сообщения об отсутствии решения
                    }

                    file = fopen("temp.txt", "w");// Открытие файла для записи
                    if (file == NULL)
                    {
                        printf("Ошибка при открытии файла.\n");// Печать сообщения об ошибке при открытии файла
                    }
                    else
                    {
                        for (int i = 0; i < rows; i++) // Цикл по строкам матрицы
                        {
                            for (int j = 0; j < cols; j++) // Цикл по элементам в строке
                            {
                                fprintf(file, "%d ", matrix[i][j]);// Запись элементов в файл
                            }
                            fprintf(file, "\n");// Запись символа новой строки для разделения строк в файле
                        }

                        
                        fclose(file);// Закрытие файла
                    }
                    for (int i = 0; i < rows; i++)// Освобождение памяти для каждой строки матрицы
                    {
                        free(matrix[i]); // Освобождение памяти для указателей на строки матрицы
                    }
                    free(matrix);
                }
            }
            else
            {
                printf("Для выбора пункта меню, вам нужно ввести число от 1-го до 2-x.\nПожалуйста, попробуйте ещё раз.\n");// Печать сообщения о неверном выборе пункта меню
            }
        }
        else if (answer == 4)
        {
            printf("Выход из игры...\n");// Печать сообщения о выходе из игры
            break;// Выход из цикла
        }
        else
        {
            printf("Для выбора пункта меню, вам нужно ввести число от 1-го до 4-x.\nПожалуйста, попробуйте ещё раз.\n");// Печать сообщения о неверном выборе пункта меню
        }
    }
    printf("Спасибо, что играли с нами.\nДо следующей игры!\n");// Печать благодарности за игру
    return 0; // Завершение программы
}
// Функция для вывода матрицы
void printMatrix(int** matrix, int rows, int cols)
{
    for (int i = 0; i < cols * 4 - 1; i++) // Цикл для вывода верхней границы матрицы
    {
        printf("_");
    }
    printf("\n");
    for (int i = 0; i < rows; i++)// Цикл для вывода значений матрицы
    {
        printf("|");
        for (int j = 0; j < cols; j++)
        {
            printf("%2d|", matrix[i][j]);
        }
        printf("\n");
    }

    for (int i = 0; i < cols * 4 - 1; i++)// Цикл для вывода нижней границы матрицы
    {
        printf("-");
    }

    printf("\n");
}

// Рекурсивная функция для нахождения решения
bool findSolution(int** matrix, int rows, int cols, int x, int y, int* rowSums, int* colSums)
{
    if (x == rows) // Проверяем, достигли ли мы конца матрицы
    {
        for (int i = 0; i < rows; i++)// Проверяем, что все суммы в строках и столбцах равны целевой сумме
        {
            if (rowSums[i] != TARGET_SUM) return false;
        }
        for (int j = 0; j < cols; j++)
        {
            if (colSums[j] != TARGET_SUM) return false;
        }
        return true; // Если все суммы равны целевой, возвращаем true
    }
    int nextX = (y + 1 < cols) ? x : x + 1; // Расчет индекса следующей ячейки
    int nextY = (y + 1 < cols) ? y + 1 : 0;

    int originalValue = matrix[x][y]; // Сохраняем исходное значение текущей ячейки и возможные значения, на которые можно заменить
    int* values = possibleValues[originalValue];

    for (int i = 0; i < 19; i++)// Сохраняем исходное значение текущей ячейки и возможные значения, на которые можно заменить
    {
        int newValue = values[i];// Проверяем все возможные варианты замены значения в текущей ячейке
        int add = newValue - originalValue;

        if (rowSums[x] + add <= TARGET_SUM && colSums[y] + add <= TARGET_SUM)// Проверяем, не превысили ли мы целевую сумму при замене значения
        {
            matrix[x][y] = newValue;// Заменяем значение в матрице, обновляем суммы в строках и столбцах
            rowSums[x] += add;
            colSums[y] += add;

            if (findSolution(matrix, rows, cols, nextX, nextY, rowSums, colSums)) // Рекурсивно вызываем функцию для слеующей ячейки
            {
                return true;
            }

            // Откат изменений (backtracking), если решение не найдено
            matrix[x][y] = originalValue;
            rowSums[x] -= add;
            colSums[y] -= add;
        }
    }
    return false; // Возвращаем false, если все возможные замены не привели к решению
}
